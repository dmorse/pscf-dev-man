<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<link rel="stylesheet" href="GDoc.css" type="text/css">
<title>pscf_f</title>
</head>
<body bgcolor="#FFFFFF">
<br />
<p>
[<a href="toc.html#top">table of contents</a>]
[<a href="master_index.html#top">master index</a>]
[<a href="comment_index.html#top">comments</a>]
[<a href="module_index.html#top">modules</a>]
[<a href="program_index.html#top">programs</a>]
[<a href="variable_index.html#top">variables</a>]
[<a href="type_index.html#top">types</a>]
[<a href="procedure_index.html#top">procedures</a>]
</p>
<h3 align="center">TABLE OF CONTENTS</h3>
<ul><li>program <a href="pscf_f.html#pscf_pd">pscf_pd</a></li>
<h2 id="pscf_pd" ><a href="pscf_f_.html#pscf_pd" target="source">pscf_pd</a></h2>
<p><strong>PROGRAM</strong></p>  <pre>
    <strong>pscf_pd</strong>
</pre>
<p><strong>PURPOSE</strong></p>  <pre>
    Main program for polymer self-consistent field theory (PSCF) for
    spatially periodic (PD) microstructures. The program can treat
    incompressible mixtures of any number of linear multiblock
    copolymers, linear homopolymers, and small molecule solvents.
 
    This program contains a main loop that reads an <a href="io/io_mod_f.html#input">input</a> script from
    standard input. The loop, and the operation of the program, ends
    when a line containing the word FINISH is encountered. The manual
    contains detailed description of the format of this script, but a
    brief description is also given here:
 
    Input Script Format:
    The first line of the <a href="io/io_mod_f.html#input">input</a> script must be of the "format i j", in
    which i and j are major and minor version numbers for the <a href="io/io_mod_f.html#input">input</a>
    script file format (e.g., "format 1 0" for v1.0). The rest of the
    <a href="io/io_mod_f.html#input">input</a> script consists of a series of blocks of <a href="io/io_mod_f.html#input">input</a> data. Each
    block begins with a blank line followed by a line containing a
    capitalized operation flag (op_flag) string, such as 'CHEMISTRY',
    'UNIT_CELL', 'DISCRETIZATION', 'ITERATION', etc.  The remainder
    of each block (if any) is a series of variable values. Each
    variable is preceded by a comment line containing the name of
    the variable, as used in the program. One and two-dimensional
    array variables may be <a href="io/io_mod_f.html#input">input</a> in any of several formats (e.g., all
    values on a single line, or on multiple lines). See the manual
    for the format of such variables.  Some operation flags, such
    as 'ITERATE' and 'SWEEP', trigger an action, beyond reading in
    variables. Reading of the script, and the program, ends when the
    'FINISH' flag is encountered.
 
    Within each block, <a href="io/io_mod_f.html#input">input</a> variables are read using the <a href="io/io_mod_f.html#input">input</a>()
    interface of the <a href="io/io_mod_f.html#io_mod">io_mod</a> module. This is an overloaded interface
    that can be used to read in a scalar or array of integer, real,
    character, or boolean data. The main program uses the comment
    style 'A' (for 'Above') of <a href="io/io_mod_f.html#io_mod">io_mod</a>, in which the value of each
    <a href="io/io_mod_f.html#input">input</a> variable is preceded by a line containing the name of
    the variable. Within each block, variables must appear in a
    predetetermined format.  The required format is documented in
    the manual, and in example scripts provided with the program.
    All data is read using the fortran read(5,*) format, so that
    the data format and use of white space is flexible, as <a href="const_mod_f.html#long">long</a>
    as each data value is of the expected data type.
 
</pre>
<p><strong>SOURCE</strong></p>  <pre>
program <strong>pscf_pd</strong>
   use <a href="const_mod_f.html#const_mod">const_mod</a>
   use <a href="io/string_mod_f.html#string_mod">string_mod</a>
   use <a href="io/io_mod_f.html#io_mod">io_mod</a>
   use <a href="io/version_mod_f.html#version_mod">version_mod</a>
   use <a href="io/field_io_mod_f.html#field_io_mod">field_io_mod</a>
   use <a href="scf/chemistry_mod_f.html#chemistry_mod">chemistry_mod</a>, only : <a href="scf/chemistry_mod_f.html#input_chemistry">input_chemistry</a>, <a href="scf/chemistry_mod_f.html#rescale_vref">rescale_vref</a>, &
                             <a href="scf/chemistry_mod_f.html#input_monomers">input_monomers</a>, <a href="scf/chemistry_mod_f.html#input_chains">input_chains</a>, <a href="scf/chemistry_mod_f.html#input_solvents">input_solvents</a>,&
                             <a href="scf/chemistry_mod_f.html#input_composition">input_composition</a>, <a href="scf/chemistry_mod_f.html#input_interaction">input_interaction</a>, &
                             <a href="scf/chemistry_mod_f.html#output_monomers">output_monomers</a>, <a href="scf/chemistry_mod_f.html#output_chains">output_chains</a>, <a href="scf/chemistry_mod_f.html#output_solvents">output_solvents</a>,&
                             <a href="scf/chemistry_mod_f.html#output_composition">output_composition</a>, <a href="scf/chemistry_mod_f.html#output_interaction">output_interaction</a>, &
                             <a href="scf/chemistry_mod_f.html#N_monomer">N_monomer</a>, <a href="scf/chemistry_mod_f.html#N_chain">N_chain</a>, <a href="scf/chemistry_mod_f.html#N_block">N_block</a>, <a href="scf/chemistry_mod_f.html#N_solvent">N_solvent</a>, <a href="scf/chemistry_mod_f.html#chi">chi</a>
   use <a href="crystal/unit_cell_mod_f.html#unit_cell_mod">unit_cell_mod</a>, only : <a href="crystal/unit_cell_mod_f.html#input_unit_cell">input_unit_cell</a>, <a href="crystal/unit_cell_mod_f.html#output_unit_cell">output_unit_cell</a>, &
                             <a href="crystal/unit_cell_mod_f.html#N_cell_param">N_cell_param</a>, <a href="crystal/unit_cell_mod_f.html#cell_param">cell_param</a>, &
                             <a href="crystal/unit_cell_mod_f.html#make_unit_cell">make_unit_cell</a>, <a href="crystal/unit_cell_mod_f.html#R_basis">R_basis</a>, <a href="crystal/unit_cell_mod_f.html#G_basis">G_basis</a>
   use <a href="crystal/group_mod_f.html#group_mod">group_mod</a>,     only : <a href="crystal/group_mod_f.html#output_group">output_group</a>
   use <a href="grid/grid_mod_f.html#grid_mod">grid_mod</a>,      only : <a href="grid/grid_mod_f.html#ngrid">ngrid</a>, <a href="grid/grid_mod_f.html#input_grid">input_grid</a>, <a href="grid/grid_mod_f.html#allocate_grid">allocate_grid</a>, <a href="grid/grid_mod_f.html#make_ksq">make_ksq</a>
   use <a href="crystal/basis_mod_f.html#basis_mod">basis_mod</a>,     only : <a href="crystal/basis_mod_f.html#N_wave">N_wave</a>, <a href="crystal/basis_mod_f.html#N_star">N_star</a>, group, &
                             <a href="crystal/basis_mod_f.html#make_basis">make_basis</a>, <a href="crystal/basis_mod_f.html#output_waves">output_waves</a>, <a href="crystal/basis_mod_f.html#release_basis">release_basis</a>

   use <a href="grid/fft3_mod_f.html#fft_mod">fft_mod</a>,        only : <a href="grid/fft3_mod_f.html#fft_plan">fft_plan</a>, <a href="grid/fft3_mod_f.html#create_fft_plan">create_fft_plan</a>, <a href="grid/fft3_mod_f.html#fft">fft</a>, <a href="grid/fft3_mod_f.html#ifft">ifft</a>

   use <a href="crystal/grid_basis_mod_f.html#grid_basis_mod">grid_basis_mod</a>
   use <a href="scf/chain_mod_f.html#chain_mod">chain_mod</a>
   use <a href="scf/scf_mod_f.html#scf_mod">scf_mod</a>,       only : <a href="scf/scf_mod_f.html#density_startup">density_startup</a>, <a href="scf/scf_mod_f.html#density">density</a>
   use <a href="iterate/iterate_mod_f.html#iterate_mod">iterate_mod</a>,   only : <a href="iterate/iterate_mod_f.html#input_iterate_param">input_iterate_param</a>, <a href="iterate/iterate_mod_f.html#output_iterate_param">output_iterate_param</a>, &
                             itr_algo, <a href="iterate/iterate_mod_f.html#domain">domain</a>, &
                             <a href="iterate/iterate_mod_f.html#iterate_NR_startup">iterate_NR_startup</a>, <a href="iterate/iterate_mod_f.html#iterate_NR">iterate_NR</a>, &
                             <a href="iterate/iterate_mod_f.html#iterate_AM_startup">iterate_AM_startup</a>, iterate_AM
   use <a href="iterate/sweep_mod_f.html#sweep_mod">sweep_mod</a>
   use <a href="response/response_mod_f.html#response_mod">response_mod</a>,  only : <a href="response/response_mod_f.html#response_startup">response_startup</a>, <a href="response/response_mod_f.html#response_sweep">response_sweep</a>
   implicit none

   ! FFT variable
   type(<a href="grid/fft3_mod_f.html#fft_plan">fft_plan</a>)  :: <a href="scf/scf_mod_f.html#plan">plan</a>

   ! SCFT variables
   real(<a href="const_mod_f.html#long">long</a>)      :: omega(:,:)      ! chemical potential field
                                      ! omega(monomer,basis function)
   real(<a href="const_mod_f.html#long">long</a>)      :: rho(:,:)        ! monomer <a href="scf/scf_mod_f.html#density">density</a> field
                                      ! rho(monomer,basis function)
   real(<a href="const_mod_f.html#long">long</a>)      :: f_Helmholtz     ! free energy, units kT / monomer
   real(<a href="const_mod_f.html#long">long</a>)      :: pressure        ! pressure * V_monomer / kT
   real(<a href="const_mod_f.html#long">long</a>)      :: stress(:)       ! d(f_Helmholtz)/d(<a href="crystal/unit_cell_mod_f.html#cell_param">cell_param</a>)
   allocatable     :: omega, rho, stress



   ! Input parameters (all others declared in modules)
   character(60)   :: group_name      ! name of crystal space group
   real(<a href="const_mod_f.html#long">long</a>)      :: chain_step      ! contour length step size
   real(<a href="const_mod_f.html#long">long</a>)      :: vref_scale      ! Factor to rescale reference volume

   ! Input and <a href="io/io_mod_f.html#output">output</a> file names
   character(60)   :: input_prefix    ! prefix for <a href="io/io_mod_f.html#input">input</a> omega file:
                                      !   input_prefix//omega
   character(60)   :: output_prefix   ! prefix for <a href="io/io_mod_f.html#output">output</a> files after iteration:
                                      !   output_prefix//out
                                      !   output_prefix//omega
                                      !   output_prefix//rho
                                      !   output_prefix//group
                                      !   output_prefix//waves
   character(60)   :: input_filename  ! name of <a href="io/io_mod_f.html#input">input</a> field file
   character(60)   :: output_filename ! name of <a href="io/io_mod_f.html#output">output</a> field file

   !  Variable for field transformations
   integer                     :: i1, i2, i3, alpha
   integer, allocatable        :: grid_size(:)
   complex(<a href="const_mod_f.html#long">long</a>), allocatable  :: k_grid(:,:,:,:)
   real(<a href="const_mod_f.html#long">long</a>), allocatable     :: r_grid(:,:,:,:)
   real(<a href="const_mod_f.html#long">long</a>), allocatable     :: omega_basis(:,:)
   real                        :: ff, qR
   real(<a href="const_mod_f.html#long">long</a>)                  :: rnodes       ! number of grid points
   character(25)               :: fmt

   ! Variables for iteration (fixed chemistry)
   integer         :: extr_order      ! extrapolation order = 1
   integer         :: itr             ! iteration index
   real(<a href="const_mod_f.html#long">long</a>)      :: error           ! error = max(residual)
   logical         :: converge        ! true if converged
   ! character(10)   :: algo

   ! Variables for sweep (sequence of parameters)
   integer         :: i, j            ! step indices
   real(<a href="const_mod_f.html#long">long</a>)      :: s_max           ! maximum value of variable s
   real(<a href="const_mod_f.html#long">long</a>)      :: s               ! <a href="iterate/sweep_mod_f.html#continuation">continuation</a> variable
   real(<a href="const_mod_f.html#long">long</a>)      :: step            ! actual step size
   real(<a href="const_mod_f.html#long">long</a>)      :: step_unit       ! unit step size

   ! Operation selection string from <a href="io/io_mod_f.html#input">input</a> script
   character(60)   :: op_string      ! Operation selection string

   ! Logical operation flags - set true as each operation requested
   ! Note: These are listed in normal sequence within <a href="io/io_mod_f.html#input">input</a> file
   logical :: monomer_flag           = .FALSE. ! monomer data read
   logical :: chain_flag             = .FALSE. ! chain data read
   logical :: solvent_flag           = .FALSE. ! solvent data read
   logical :: composition_flag       = .FALSE. ! composition data read
   logical :: interaction_flag       = .FALSE. ! interaction data read
   logical :: unit_cell_flag         = .FALSE. ! unit_cell made
   logical :: discretize_flag        = .FALSE. ! grid and ds made
   logical :: prefix_flag            = .FALSE. ! io file prefixes read
   logical :: basis_flag             = .FALSE. ! symmetrized basis made
   logical :: omega_flag             = .FALSE. ! initial omega exists
   logical :: iterate_flag           = .FALSE. ! 1st iteration requested
   logical :: output_flag            = .FALSE. ! deferred iterate <a href="io/io_mod_f.html#output">output</a>
   logical :: sweep_flag             = .FALSE. ! sweep requested
   logical :: rho_flag               = .FALSE. ! initial_rho_exist

   ! Timing variables
   real(<a href="const_mod_f.html#long">long</a>) :: start_time, basis_time, scf_time
   real(<a href="const_mod_f.html#long">long</a>) :: rpa_time

   ! File Unit numbers (parameters)
   integer, parameter :: out_unit   = 21 ! <a href="io/io_mod_f.html#output">output</a> summary
   integer, parameter :: field_unit = 22 ! omega and rho fields
   integer            :: ierr            ! error msg for file io

   ! File format version numbers
   type(<a href="io/version_mod_f.html#version_type">version_type</a>) :: version      ! <a href="io/io_mod_f.html#input">input</a> script format
   !------------------------------------------------------------------

   call cpu_time(start_time)

   ! Set defaults for parameter I/O - see <a href="io/io_mod_f.html#io_mod">io_mod</a>
   call <a href="io/io_mod_f.html#set_echo">set_echo</a>(1)                ! echo inputs to standard out
   call <a href="io/io_mod_f.html#set_com_style">set_com_style</a>('A','A','A') ! comments on line above data
   call <a href="io/io_mod_f.html#set_com_use">set_com_use</a>('R')           ! replace comment in echoed <a href="io/io_mod_f.html#output">output</a>
   call <a href="io/io_mod_f.html#set_io_units">set_io_units</a>(i=5,o=6)      ! set standard in and out units

   ! Read file format version from <a href="io/io_mod_f.html#input">input</a> script, echo to stdout
   call <a href="io/version_mod_f.html#input_version">input_version</a>(version, 5)
   call <a href="io/version_mod_f.html#output_version">output_version</a>(version, 6)

   ! Main operation loop - infinite loop
   op_loop : do

      ! Read operation string from stdin
      read(5,*)
      read(5,*) op_string

      ! Echo to stdout
      write(6,*)
      call <a href="io/io_mod_f.html#output">output</a>(trim(op_string),f="N",j="L",o=6)

      ! Print any deferred <a href="io/io_mod_f.html#output">output</a> from preceding ITERATE command
      if (output_flag) then
         if (trim(op_string) == "SWEEP") then
            call output_summary(trim(output_prefix)//'0.')
            call output_fields(trim(output_prefix)//'0.')
         else
            call output_summary(output_prefix)
            call output_fields(output_prefix)
         end if
         output_flag = .FALSE.
      endif

      select case(trim(op_string))

      case ("MONOMERS")

        ! Input <a href="scf/chemistry_mod_f.html#N_monomer">N_monomer</a> and <a href="scf/chemistry_mod_f.html#kuhn">kuhn</a> array
        ! See <a href="scf/chemistry_mod_f.html#chemistry_mod">chemistry_mod</a> and users manual

         ! Preconditions
         if (monomer_flag) then
            write(6,*) "Error: MONOMERS can only be read once"
            exit op_loop
         end if

         monomer_flag = .TRUE.
         call <a href="scf/chemistry_mod_f.html#input_monomers">input_monomers</a>(5,'F')

      case ("CHAINS")

        ! Input N_chains, <a href="scf/chemistry_mod_f.html#block_monomer">block_monomer</a>, <a href="scf/chemistry_mod_f.html#block_length">block_length</a>
        ! See <a href="scf/chemistry_mod_f.html#chemistry_mod">chemistry_mod</a> and users manual

         ! Check preconditions (must know <a href="scf/chemistry_mod_f.html#N_monomer">N_monomer</a> first)
         if (chain_flag) then
            write(6,*) "Error: CHAINS can only be read once"
            exit op_loop
         end if
         if (.not.monomer_flag) then
            write(6,*) "Error: Must read MONOMERS before CHAINS"
            exit op_loop
         end if

         chain_flag  = .TRUE.
         call <a href="scf/chemistry_mod_f.html#input_chains">input_chains</a>(5,'F')

      case ("SOLVENTS")

        ! Input N_solvents, <a href="scf/chemistry_mod_f.html#solvent_monomer">solvent_monomer</a>, <a href="scf/chemistry_mod_f.html#solvent_size">solvent_size</a>
        ! See <a href="scf/chemistry_mod_f.html#chemistry_mod">chemistry_mod</a> and users manual

         ! Check preconditions (must know <a href="scf/chemistry_mod_f.html#N_monomer">N_monomer</a> first)
         if (solvent_flag) then
            write(6,*) "Error: SOLVENTS can only be read once"
            exit op_loop
         end if
         if (.not.monomer_flag) then
            write(6,*) "Error: Must read MONOMERS before SOLVENTS"
            exit op_loop
         end if
         if (composition_flag) then
            write(6,*) "Error: Cannot read SOLVENTS after COMPOSITION"
            exit op_loop
         end if
         solvent_flag  = .TRUE.

         call <a href="scf/chemistry_mod_f.html#input_solvents">input_solvents</a>(5,'F')

      case ("COMPOSITION")

        ! Input <a href="scf/chemistry_mod_f.html#ensemble">ensemble</a>, <a href="scf/chemistry_mod_f.html#phi_chain">phi_chain</a> and <a href="scf/chemistry_mod_f.html#phi_solvent">phi_solvent</a>, or <a href="scf/chemistry_mod_f.html#mu_chain">mu_chain</a> and <a href="scf/chemistry_mod_f.html#mu_solvent">mu_solvent</a>
        ! See <a href="scf/chemistry_mod_f.html#chemistry_mod">chemistry_mod</a> and users manual

         ! Check preconditions (must know <a href="scf/chemistry_mod_f.html#N_chain">N_chain</a> and <a href="scf/chemistry_mod_f.html#N_solvent">N_solvent</a> first)
         if ( .not. chain_flag ) then
            write(6,*) &
            "Error: Must read CHAINS before COMPOSITION"
            exit op_loop
         end if
         iterate_flag = .FALSE.
         composition_flag = .TRUE.

         call <a href="scf/chemistry_mod_f.html#input_composition">input_composition</a>(5,'F')

      case ("INTERACTION")

         ! Input Flory-Huggins <a href="scf/chemistry_mod_f.html#chi">chi</a> interaction parameters.
         ! Input <a href="scf/chemistry_mod_f.html#interaction_type">interaction_type</a> and:
         !    <a href="scf/chemistry_mod_f.html#chi">chi</a> (if <a href="scf/chemistry_mod_f.html#interaction_type">interaction_type</a> = '<a href="scf/chemistry_mod_f.html#chi">chi</a>'), or
         !    chi_a, chi_b, & <a href="scf/chemistry_mod_f.html#temperature">temperature</a> (if <a href="scf/chemistry_mod_f.html#interaction_type">interaction_type</a> = 'chi_T')
         ! See <a href="scf/chemistry_mod_f.html#chemistry_mod">chemistry_mod</a> and users manual

         ! Check preconditions (must know <a href="scf/chemistry_mod_f.html#N_monomer">N_monomer</a> first)
         if (.not.monomer_flag) then
            write(6,*) "Error: Must read MONOMERS before INTERACTION"
            exit op_loop
         end if
         iterate_flag = .FALSE.
         interaction_flag = .TRUE.

         call <a href="scf/chemistry_mod_f.html#input_interaction">input_interaction</a>(5,'F')


      case ('UNIT_CELL')

         ! Check preconditions
         if (unit_cell_flag) then
            write(6,*) "Error: UNIT_CELL can only be read once"
            exit op_loop
         end if
         unit_cell_flag = .TRUE.

         ! Read unit cell parameters (see <a href="crystal/unit_cell_mod_f.html#unit_cell_mod">unit_cell_mod</a>)
         call <a href="crystal/unit_cell_mod_f.html#input_unit_cell">input_unit_cell</a>(5,'F')
         allocate(grid_size(<a href="const_mod_f.html#dim">dim</a>))

         ! Construct initial unit cell (see <a href="crystal/unit_cell_mod_f.html#unit_cell_mod">unit_cell_mod</a>)
         call <a href="crystal/unit_cell_mod_f.html#make_unit_cell">make_unit_cell</a>

      case ('DISCRETIZATION')

         ! Read spatial and contour length discretization of PDE

         ! Check preconditions (Needs <a href="scf/chemistry_mod_f.html#N_monomer">N_monomer</a> and unit_cell parameters)
         if (discretize_flag) then
            write(6,*) "Error: DISCRETIZATION can only be read once"
            exit op_loop
         end if
         if (.not.monomer_flag) then
            write(6,*) "Error: Must read MONOMERS before DISCRETIZATION"
            exit op_loop
         else if ( .not. unit_cell_flag ) then
            write(6,*) "Error: Must read UNIT_CELL before DISCRETIZATION"
            exit op_loop
         end if
         discretize_flag = .TRUE.

         ! Input <a href="grid/grid_mod_f.html#ngrid">ngrid</a> = number of points in FFT grid in each direction
         call <a href="grid/grid_mod_f.html#input_grid">input_grid</a>
         call <a href="grid/grid_mod_f.html#allocate_grid">allocate_grid</a>(<a href="scf/chemistry_mod_f.html#N_monomer">N_monomer</a>)

         !call <a href="io/io_mod_f.html#input">input</a>(extr_order,'extr_order')
         extr_order = 1
         call <a href="io/io_mod_f.html#input">input</a>(chain_step,'chain_step')

      case ('BASIS')

         ! Construct symmetry-adapated basis functions. See <a href="crystal/basis_mod_f.html#basis_mod">basis_mod</a>

         ! Check preconditions (needs unit cell and grid)
         if (basis_flag) then
            write(6,*) "Error: BASIS can only be read once"
            exit op_loop
         end if
         if (.not. unit_cell_flag) then
            write(6,*) "Error: Must read UNIT_CELL before BASIS"
            exit op_loop
         else if (.not.discretize_flag) then
            write(6,*) "Error: Must read DISCRETIZATION before BASIS"
            exit op_loop
         end if
         basis_flag = .TRUE.

         ! Read name of space group used to construct basis functions.
         ! The string group_name can be a space group symbol, a space
         ! group number, or the name of a file containing the elements
         ! of the group. See <a href="crystal/space_groups_mod_f.html#space_groups">space_groups</a> in module space_group_mod.
         call <a href="io/io_mod_f.html#input">input</a>(group_name,'group_name')

         ! Construct basis functions (see <a href="crystal/basis_mod_f.html#basis_mod">basis_mod</a>)
         call <a href="crystal/basis_mod_f.html#make_basis">make_basis</a>(<a href="crystal/unit_cell_mod_f.html#R_basis">R_basis</a>,<a href="crystal/unit_cell_mod_f.html#G_basis">G_basis</a>,group_name,<a href="grid/grid_mod_f.html#ngrid">ngrid</a>,grid_flag=.TRUE.)

         ! Output <a href="crystal/basis_mod_f.html#N_star">N_star</a> (# of symmetrized basis functions) to stdout
         call <a href="io/io_mod_f.html#output">output</a>(<a href="crystal/basis_mod_f.html#N_star">N_star</a>,'<a href="crystal/basis_mod_f.html#N_star">N_star</a>',o=6)

         ! Allocate omega, rho, stress (internal routine)
         call allocate_scf_arrays

      case ('RESCALE')

         ! This command should be read immediately before iterate.

         ! Rescale monomer reference volume. Change values of <a href="scf/chemistry_mod_f.html#kuhn">kuhn</a>,
         ! <a href="scf/chemistry_mod_f.html#chi">chi</a>, <a href="scf/chemistry_mod_f.html#block_length">block_length</a>, and <a href="scf/chemistry_mod_f.html#solvent_size">solvent_size</a> parameter arrays, and
         ! the omega field, to obtain an equivalent set of parameters
         ! and fields.

         ! Check preconditions
         if (.not.composition_flag) then
            write(6,*) "Error: Must read COMPOSITION before RESCALE"
            exit op_loop
         else if (.not.interaction_flag) then
            write(6,*) "Error: Must read INTERACTION before RESCALE"
            exit op_loop
         else if (.not.basis_flag) then
            write(6,*) "Error: Must read BASIS before RESCALE"
            exit op_loop
         end if
         iterate_flag = .FALSE.
         omega_flag = .TRUE.

         ! Read name of <a href="io/io_mod_f.html#input">input</a> omega file
         call <a href="io/io_mod_f.html#input">input</a>(input_filename, 'input_filename')  

         ! Read scale factor: vref -> vref/vref_scale
         call <a href="io/io_mod_f.html#input">input</a>(vref_scale, 'vref_scale')

         ! Read omega field
         open(unit=field_unit,file=trim(input_filename), status='old', iostat=ierr)
         if (ierr/=0) stop "Error while opening omega file"
         call <a href="io/field_io_mod_f.html#input_field">input_field</a>(omega, field_unit)
         close(field_unit)

         ! Rescale <a href="scf/chemistry_mod_f.html#kuhn">kuhn</a>, <a href="scf/chemistry_mod_f.html#chi">chi</a>, <a href="scf/chemistry_mod_f.html#block_length">block_length</a>, <a href="scf/chemistry_mod_f.html#solvent_size">solvent_size</a>
         ! See <a href="scf/chemistry_mod_f.html#chemistry_mod">chemistry_mod</a>
         call <a href="scf/chemistry_mod_f.html#rescale_vref">rescale_vref</a>(vref_scale)

         ! Rescale omega field
         omega = omega/vref_scale

      case ('ITERATE')

         ! Iterate to convergence for one set of parameters
         ! See <a href="iterate/iterate_mod_f.html#iterate_mod">iterate_mod</a>
         ! Check preconditions
         if (.not.composition_flag) then
            write(6,*) "Error: Must read COMPOSITION before ITERATE"
            exit op_loop
         else if (.not.interaction_flag) then
            write(6,*) "Error: Must read INTERACTION before ITERATE"
            exit op_loop
         else if (.not.unit_cell_flag) then
            write(6,*) "Error: Must read UNIT_CELL before ITERATE"
            exit op_loop
         else if (.not.discretize_flag) then
            write(6,*) "Error: Must read DISCRETIZATION before ITERATE"
            exit op_loop
         else if (.not.basis_flag) then
            write(6,*) "Error: Must read BASIS before ITERATE"
            exit op_loop
         end if

         ! Read omega file, if not <a href="io/io_mod_f.html#input">input</a> preceding RESCALE command
         if (.not.omega_flag) then
            call <a href="io/io_mod_f.html#input">input</a>(input_filename, 'input_filename')  ! <a href="io/io_mod_f.html#input">input</a>  file prefix
            open(unit=field_unit,file=trim(input_filename),&
                              status='old',iostat=ierr)
            if (ierr/=0) stop "Error while opening omega source file."
            call <a href="io/field_io_mod_f.html#input_field">input_field</a>(omega,field_unit)
            close(field_unit)
            omega_flag = .TRUE.
         end if
         call <a href="io/io_mod_f.html#input">input</a>(output_prefix,'output_prefix') ! <a href="io/io_mod_f.html#output">output</a> file prefix

         iterate_flag = .TRUE.

         call cpu_time(basis_time)
         basis_time = basis_time - start_time
         call cpu_time(start_time)

         ! Read parameters for iteration
         call <a href="iterate/iterate_mod_f.html#input_iterate_param">input_iterate_param</a>

         ! Allocate and initialize chain objects used in <a href="scf/scf_mod_f.html#scf_mod">scf_mod</a>
         ! Create <a href="grid/fft3_mod_f.html#fft_plan">fft_plan</a>, which is saved in <a href="scf/scf_mod_f.html#scf_mod">scf_mod</a> as public variable
         call <a href="scf/scf_mod_f.html#density_startup">density_startup</a>(<a href="grid/grid_mod_f.html#ngrid">ngrid</a>, extr_order, chain_step,&
                                  update_chain=.false.)

         if (itr_algo=='NR') then

             ! Allocate private arrays for Newton-Raphson iteration
             call <a href="iterate/iterate_mod_f.html#iterate_NR_startup">iterate_NR_startup</a>(<a href="crystal/basis_mod_f.html#N_star">N_star</a>)

             write(6,FMT = "( / '************************************' / )" )
             ! Main Newton-Raphson iteration loop
             call <a href="iterate/iterate_mod_f.html#iterate_NR">iterate_NR</a>(      &
                      <a href="crystal/basis_mod_f.html#N_star">N_star</a>,      &! # of basis functions
                      omega,       &! chemical potential field (IN/OUT)
                      itr,         &! actual number of interations
                      converge,    &! = .TRUE. if converged
                      error,       &! final error = max(residuals)
                      rho,         &! monomer <a href="scf/scf_mod_f.html#density">density</a> field
                      f_Helmholtz, &! Helmholtz free energy per monomer/kT
                      pressure,    &! pressure * monomer volume / kT
                      stress       &! d(free energy)/d(cell parameters)
                           )

         else if(itr_algo=='AM') then

             ! Allocate private arrays for Anderson-Mixing iteration
             call <a href="iterate/iterate_mod_f.html#iterate_AM_startup">iterate_AM_startup</a>(<a href="crystal/basis_mod_f.html#N_star">N_star</a>)

             call iterate_AM(      &
                      <a href="crystal/basis_mod_f.html#N_star">N_star</a>,      &! # of basis functions
                      omega,       &! chemical potential field (IN/OUT)
                      itr,         &! actual number of interations
                      converge,    &! = .TRUE. if converged
                      error,       &! final error = max(residuals)
                      rho,         &! monomer <a href="scf/scf_mod_f.html#density">density</a> field
                      f_Helmholtz, &! Helmholtz free energy per monomer/kT
                      pressure,    &! pressure * monomer volume / kT
                      stress       &! d(free energy)/d(cell parameters)
                           )

         endif

         ! Defer <a href="io/io_mod_f.html#output">output</a> to beginning of next operation
         ! If next operation is SWEEP, '0.' will be added to output_prefix
         output_flag = .TRUE.

         call cpu_time(scf_time)
         scf_time = scf_time - start_time

      case ('SWEEP')

         ! Iterate to convergences for a sequence of sets of parameters.
         ! See sweep_mod.

         ! Must be preceded by successful ITERATE for first solution.
         if (.not.iterate_flag) then
             write(6,*) &
                "Error: Must call ITERATE (1st iteration) before SWEEP"
            exit op_loop
         else if (.not.converge) then
            write(6,*) "Error: 1st iteration failed to converge"
            exit op_loop
         end if
         sweep_flag = .TRUE.

         ! Read parameters needed by sweep
         call <a href="io/io_mod_f.html#input">input</a>(s_max,'s_max')           ! max(contour variable s)
         call <a href="iterate/sweep_mod_f.html#input_increments">input_increments</a>(5,'N',<a href="iterate/iterate_mod_f.html#domain">domain</a>) ! see <a href="iterate/sweep_mod_f.html#sweep_mod">sweep_mod</a>

         ! Initialize contour variable s = 0.0 -> s_max
         s = 0.0_long

         ! Initialize history arrays
         call <a href="iterate/sweep_mod_f.html#history_setup">history_setup</a>
         call <a href="iterate/sweep_mod_f.html#update_history">update_history</a>(s,omega,<a href="crystal/unit_cell_mod_f.html#cell_param">cell_param</a>,<a href="iterate/iterate_mod_f.html#domain">domain</a>)

         ! Loop over sweep through parameters
         i = 0
         step_unit = 1.0_long
         sweep_loop : do

            if (i == 0) then
               step = 0.1*step_unit
            else if (i == 1) then
               if (converge) then
                  step = 0.9*step_unit
               else
                  step = step_unit - s
               end if
            else if (i > 1) then
               step = step_unit
            end if

            s = s + step
            call <a href="iterate/sweep_mod_f.html#increment_parameters">increment_parameters</a>(step, <a href="iterate/iterate_mod_f.html#domain">domain</a>, <a href="crystal/unit_cell_mod_f.html#cell_param">cell_param</a>)

            write(6, FMT = "('************************************'/ )" )
            write(6, FMT = "('s =',f10.4)" ) s
            call cpu_time(start_time)

            ! 1st order <a href="iterate/sweep_mod_f.html#continuation">continuation</a> of omega and <a href="crystal/unit_cell_mod_f.html#cell_param">cell_param</a>
            call <a href="iterate/sweep_mod_f.html#continuation">continuation</a>(step, <a href="iterate/iterate_mod_f.html#domain">domain</a>, omega, <a href="crystal/unit_cell_mod_f.html#cell_param">cell_param</a>)

            ! Reconstruct unit cell and all values of |k|^2
            call <a href="crystal/unit_cell_mod_f.html#make_unit_cell">make_unit_cell</a>
            call <a href="grid/grid_mod_f.html#make_ksq">make_ksq</a>(<a href="crystal/unit_cell_mod_f.html#G_basis">G_basis</a>)

            ! Rebuild chains
            call <a href="scf/scf_mod_f.html#density_startup">density_startup</a>(<a href="grid/grid_mod_f.html#ngrid">ngrid</a>, extr_order, chain_step, &
                                 update_chain=.TRUE.)

            ! Main iteration routine
            if (itr_algo=='NR')then

               call <a href="iterate/iterate_mod_f.html#iterate_NR">iterate_NR</a>( &
                   <a href="crystal/basis_mod_f.html#N_star">N_star</a>,      &! # of basis functions
                   omega,       &! chemical potential field (IN/OUT)
                   itr,         &! actual number of interations
                   converge,    &! = .TRUE. if converged
                   error,       &! final error = max(residuals)
                   rho,         &! monomer <a href="scf/scf_mod_f.html#density">density</a> field
                   f_Helmholtz, &! Helmholtz free energy per monomer/kT
                   pressure,    &! pressure * monomer volume/kT
                   stress       &! d(free energy)/d(cell parameters)
                   )

            else if (itr_algo=='AM')then

               call iterate_AM(      &
                        <a href="crystal/basis_mod_f.html#N_star">N_star</a>,      &! # of basis functions
                        omega,       &! chemical potential field (IN/OUT)
                        itr,         &! actual number of interations
                        converge,    &! = .TRUE. if converged
                        error,       &! final error = max(residuals)
                        rho,         &! monomer <a href="scf/scf_mod_f.html#density">density</a> field
                        f_Helmholtz, &! Helmholtz free energy per monomer/kT
                        pressure,    &! pressure * monomer volume / kT
                        stress       &! d(free energy)/d(cell parameters)
                             )

            end if

            if (converge) then

               i = i + 1
               call <a href="iterate/sweep_mod_f.html#update_history">update_history</a>(s, omega, <a href="crystal/unit_cell_mod_f.html#cell_param">cell_param</a>, <a href="iterate/iterate_mod_f.html#domain">domain</a>)

               call cpu_time(scf_time)
               scf_time = scf_time - start_time

               ! Output out, rho, and omega files if s is an integer
               if ( abs(s-float(nint(s))) < 0.001_long ) then
                  j = nint(s)
                  ! Appending 'j.' to output_prefix in file names
                  call output_summary( &
                      trim(output_prefix)//trim(<a href="io/string_mod_f.html#int_string">int_string</a>(j))//'.' )
                  call output_fields( &
                      trim(output_prefix)//trim(<a href="io/string_mod_f.html#int_string">int_string</a>(j))//'.' )
               end if
               write(6,*)

            else if (step_unit > ( (1.0/16.0) + 0.001 ) ) then

               ! Backtrack to previous state point
               s = s - step
               call <a href="iterate/sweep_mod_f.html#increment_parameters">increment_parameters</a>(-step, <a href="iterate/iterate_mod_f.html#domain">domain</a>, <a href="crystal/unit_cell_mod_f.html#cell_param">cell_param</a>)

               ! Halve step size
               step_unit = 0.5*step_unit

               write(6, FMT="( / 'Backtrack and halve step_unit' / )" )
               cycle

            else ! If not.converge and step_unit <= 1/16, stop.

               write(6,*)
               write(6,*) 'Failed to converge - stop program'
               stop

            end if

            if ( (s + 0.001) >= s_max ) exit sweep_loop

         end do sweep_loop
         ! end loop over sweep through parameters


      case ('RESPONSE')

         ! Calculate and diagonalize linear SCF response functions for
         ! a periodic microstructure. See response_mod.

         ! Check preconditions (Must iterate to convergence first)
         if (.not. iterate_flag) then
            write(6,*) "Error: Must ITERATE before calculating RESPONSE"
            exit op_loop
         end if
         iterate_flag = .FALSE.

         call <a href="response/response_mod_f.html#response_startup">response_startup</a>(Ngrid, chain_step, order=1)
         call <a href="response/response_mod_f.html#response_sweep">response_sweep</a>(Ngrid, output_prefix)

         call <a href="crystal/basis_mod_f.html#release_basis">release_basis</a>()
         call <a href="crystal/basis_mod_f.html#make_basis">make_basis</a>(<a href="crystal/unit_cell_mod_f.html#R_basis">R_basis</a>,<a href="crystal/unit_cell_mod_f.html#G_basis">G_basis</a>,group_name,Ngrid,grid_flag=.TRUE.)

      case ('OUTPUT_GROUP')

         ! Check preconditions (Needs group created in BASIS block)
         if (.not. basis_flag) then
            write(6,*) "Error: Must read BASIS before OUTPUT_GROUP"
            exit op_loop
         end if
         iterate_flag = .FALSE.
         omega_flag = .FALSE.

         open(unit=field_unit, &
              file=trim(output_prefix)//'group',status='replace')
         call <a href="crystal/group_mod_f.html#output_group">output_group</a>(group,field_unit)
         close(field_unit)

      case ('OUTPUT_WAVES')

         ! Check preconditions (Needs BASIS)
         if (.not. basis_flag) then
            write(6,*) "Error: Must read BASIS before OUTPUT_WAVES"
            exit op_loop
         end if

         open(unit=field_unit,file=trim(output_prefix)//'waves',&
              status='replace')
         call <a href="crystal/basis_mod_f.html#output_waves">output_waves</a>(field_unit, group_name)
         close(field_unit)

      case ('FIELD_TO_RGRID')

         ! Read representation of field as list of coefficients of
         ! symmetrized basis functions, <a href="io/io_mod_f.html#output">output</a> file containing field
         ! values at grid points (rgrid).

         ! Check preconditions for FIELD_TO_RGRID
         if ( .not. unit_cell_flag ) then
            write(6,*) "Error: Must read UNIT_CELL before FIELD_TO_GRID"
            exit op_loop
         else if (.not.discretize_flag) then
            write(6,*) &
                  "Error: Must read DISCRETIZATION before FIELD_TO_GRID"
            exit op_loop
         else if (.not.basis_flag) then
            write(6,*) "Error: Must read BASIS before FIELD_TO_GRID"
            exit op_loop
         end if
         iterate_flag = .FALSE.
         omega_flag = .FALSE.

         ! Read <a href="io/io_mod_f.html#input">input</a> and <a href="io/io_mod_f.html#output">output</a> file names from <a href="io/io_mod_f.html#input">input</a> script
         call <a href="io/io_mod_f.html#input">input</a>(input_filename,'input_filename')
         call <a href="io/io_mod_f.html#input">input</a>(output_filename,'output_filename')

         ! Read field (coefficients of basis functions) from input_filename
         open(unit=field_unit,file=trim(input_filename),status='old')
         call <a href="io/field_io_mod_f.html#input_field">input_field</a>(rho,field_unit)
         close(field_unit)

         ! Write values of field on a grid to output_filename
         open(unit=field_unit,file=trim(output_filename),status='replace')
         call <a href="io/field_io_mod_f.html#output_field_grid">output_field_grid</a>(rho,field_unit,group_name,<a href="grid/grid_mod_f.html#ngrid">ngrid</a>)
         close(field_unit)

      case ('KGRID_TO_RGRID')

         ! Read representation of field as list of coefficients of
         ! on FFT grid (kgrid) and <a href="io/io_mod_f.html#output">output</a> file containing field
         ! values at grid points (rgrid).

         ! Check preconditions for KGRID_TO_RGRID
         if ( .not. unit_cell_flag ) then
            write(6,*) "Error: Must read UNIT_CELL before KGRID_TO_RGRID"
            exit op_loop
         else if (.not.discretize_flag) then
            write(6,*) &
                  "Error: Must read DISCRETIZATION before KGRID_TO_RGRID"
            exit op_loop
         else if (.not.basis_flag) then
            write(6,*) "Error: Must read BASIS before KGRID_TO_RGRID"
            exit op_loop
         end if
         iterate_flag = .FALSE.
         omega_flag = .FALSE.

         ! Read <a href="io/io_mod_f.html#input">input</a> and <a href="io/io_mod_f.html#output">output</a> file names from <a href="io/io_mod_f.html#input">input</a> script
         call <a href="io/io_mod_f.html#input">input</a>(input_filename,'input_filename')
         call <a href="io/io_mod_f.html#input">input</a>(output_filename,'output_filename')

         if (.not.allocated(k_grid)) then
            allocate(k_grid(0:<a href="grid/grid_mod_f.html#ngrid">ngrid</a>(1)/2, 0:<a href="grid/grid_mod_f.html#ngrid">ngrid</a>(2)-1, 0:<a href="grid/grid_mod_f.html#ngrid">ngrid</a>(3)-1, <a href="scf/chemistry_mod_f.html#N_monomer">N_monomer</a>))
         end if

         ! Open input_filename, read header, check grid dimensions
         open(unit=field_unit,file=trim(input_filename),status='old')
         ! Skip first 13 lines
         do i=1,14
            read(field_unit,*)
         end do
         read (field_unit,*) grid_size
         if (grid_size(1) /= <a href="grid/grid_mod_f.html#ngrid">ngrid</a>(1)) then
            write(6,*) "Error: Inconsistent grid in <a href="io/io_mod_f.html#input">input</a> kgrid file"
            exit op_loop
         end if
         if (<a href="const_mod_f.html#dim">dim</a> > 1) then
            if (grid_size(2) /= <a href="grid/grid_mod_f.html#ngrid">ngrid</a>(2)) then
               write(6,*) "Error: Inconsistent grid in <a href="io/io_mod_f.html#input">input</a> kgrid file"
               exit op_loop
            end if
            if (<a href="const_mod_f.html#dim">dim</a> > 2) then
               if (grid_size(3) /= <a href="grid/grid_mod_f.html#ngrid">ngrid</a>(3)) then
                  write(6,*) "Error: Inconsistent grid in <a href="io/io_mod_f.html#input">input</a> kgrid file"
                  exit op_loop
               end if
            end if
         end if

         ! Read elements of k_grid (Fourier coefficients) from <a href="io/io_mod_f.html#input">input</a> file
         k_grid = 0.0
         do i1 = 0, <a href="grid/grid_mod_f.html#ngrid">ngrid</a>(1)/2
            do i2 = 0, <a href="grid/grid_mod_f.html#ngrid">ngrid</a>(2) - 1
               do i3 = 0, <a href="grid/grid_mod_f.html#ngrid">ngrid</a>(3) - 1
                  read(field_unit,*) k_grid(i1,i2,i3,:)
               end do
            end do
         end do
         close(field_unit)

         ! Transform to symmetry-adapated Fourier expansion of rho
         call <a href="grid/fft3_mod_f.html#create_fft_plan">create_fft_plan</a>(<a href="grid/grid_mod_f.html#ngrid">ngrid</a>, <a href="scf/scf_mod_f.html#plan">plan</a>)
         do alpha=1, <a href="scf/chemistry_mod_f.html#N_monomer">N_monomer</a>
            call <a href="crystal/grid_basis_mod_f.html#kgrid_to_basis">kgrid_to_basis</a>(k_grid(:,:,:,alpha), rho(alpha,:))
         end do

         ! Write rho field in coordinate grid format
         open(unit=field_unit,file=trim(output_filename),status='replace')
         call <a href="io/field_io_mod_f.html#output_field_grid">output_field_grid</a>(rho, field_unit, group_name, <a href="grid/grid_mod_f.html#ngrid">ngrid</a>)
         close(field_unit)

         deallocate(k_grid)

      case ('RGRID_TO_FIELD')

         ! Read coordinate-grid representation of a field
         ! Write representation in symmetry-adapated Fourier expansion

         ! Check preconditions for RGRID_TO_FIELD
         if ( .not. unit_cell_flag ) then
            write(6,*) "Error: Must read UNIT_CELL before RGRID_TO_FIELD"
            exit op_loop
         else if (.not.discretize_flag) then
            write(6,*) &
                  "Error: Must read DISCRETIZATION before RGRID_TO_FIELD"
            exit op_loop
         else if (.not.basis_flag) then
            write(6,*) "Error: Must read BASIS before RGRID_TO_FIELD"
            exit op_loop
         end if
         iterate_flag = .FALSE.
         omega_flag = .FALSE.

         ! Read <a href="io/io_mod_f.html#input">input</a> and <a href="io/io_mod_f.html#output">output</a> file names from <a href="io/io_mod_f.html#input">input</a> script
         call <a href="io/io_mod_f.html#input">input</a>(input_filename,'input_filename')
         call <a href="io/io_mod_f.html#input">input</a>(output_filename,'output_filename')

         ! Allocate required memory
         if (.not.allocated(r_grid)) then
            allocate(r_grid(0:<a href="grid/grid_mod_f.html#ngrid">ngrid</a>(1)-1,0:<a href="grid/grid_mod_f.html#ngrid">ngrid</a>(2)-1,0:<a href="grid/grid_mod_f.html#ngrid">ngrid</a>(3)-1,<a href="scf/chemistry_mod_f.html#N_monomer">N_monomer</a>))
         end if
         if (.not.allocated(k_grid)) then
            allocate(k_grid(0:<a href="grid/grid_mod_f.html#ngrid">ngrid</a>(1)/2,0:<a href="grid/grid_mod_f.html#ngrid">ngrid</a>(2)-1,0:<a href="grid/grid_mod_f.html#ngrid">ngrid</a>(3)-1,<a href="scf/chemistry_mod_f.html#N_monomer">N_monomer</a>))
         end if

         ! Open <a href="io/io_mod_f.html#input">input</a> file and read header, including grid dimensions
         open(unit=field_unit,file=trim(input_filename),status='old')
         ! Skip first 13 lines
         do i=1,14
            read(field_unit, *)
         end do
         read(field_unit,*) grid_size
         if (grid_size(1) /= <a href="grid/grid_mod_f.html#ngrid">ngrid</a>(1)) then
            write(6,*) "Error: inconsistent grid size in kgrid <a href="io/io_mod_f.html#input">input</a> file"
            exit op_loop
         endif
         if (<a href="const_mod_f.html#dim">dim</a> > 1) then
            if (grid_size(2) /= <a href="grid/grid_mod_f.html#ngrid">ngrid</a>(2)) then
               write(6,*) "Error: Inconsistent grid size in rho_kgrid file"
               exit op_loop
            end if
            if (<a href="const_mod_f.html#dim">dim</a> > 2) then
               if (grid_size(3) /= <a href="grid/grid_mod_f.html#ngrid">ngrid</a>(3)) then
                  write(6,*) "Error: Inconsistent grid size in kgrid file"
                  exit op_loop
               end if
            end if
         end if

         ! Read field values at grid points from <a href="io/io_mod_f.html#input">input</a> file
         r_grid=0.0
         do i3 = 0, <a href="grid/grid_mod_f.html#ngrid">ngrid</a>(3) - 1
            do i2 = 0, <a href="grid/grid_mod_f.html#ngrid">ngrid</a>(2) - 1
               do i1 = 0, <a href="grid/grid_mod_f.html#ngrid">ngrid</a>(1) - 1
                   read(field_unit,*) r_grid(i1,i2,i3,:)
               end do
            end do
         end do
         close(field_unit)

         ! Transform to symmetry-adapated rho field
         call <a href="grid/fft3_mod_f.html#create_fft_plan">create_fft_plan</a>(<a href="grid/grid_mod_f.html#ngrid">ngrid</a>, <a href="scf/scf_mod_f.html#plan">plan</a>)
         rnodes=dble( <a href="scf/scf_mod_f.html#plan">plan</a>%n(1) * <a href="scf/scf_mod_f.html#plan">plan</a>%n(2) * <a href="scf/scf_mod_f.html#plan">plan</a>%n(3) )
         do alpha = 1, <a href="scf/chemistry_mod_f.html#N_monomer">N_monomer</a>
            call <a href="grid/fft3_mod_f.html#fft">fft</a>(<a href="scf/scf_mod_f.html#plan">plan</a>,r_grid(:,:,:,alpha), k_grid(:,:,:,alpha))
            k_grid(:,:,:,alpha) = k_grid(:,:,:,alpha)/rnodes
            call <a href="crystal/grid_basis_mod_f.html#kgrid_to_basis">kgrid_to_basis</a>(k_grid(:,:,:,alpha), rho(alpha,:))
         end do

         open(unit=field_unit, file=trim(output_filename), status='replace')
         call <a href="io/field_io_mod_f.html#output_field">output_field</a>(rho, field_unit, group_name)
         close(field_unit)

         deallocate(r_grid)
         deallocate(k_grid)

      case('RHO_TO_OMEGA')

         ! (1) Read a rho field from file, in symmetry-adapted format.
         ! (2) Generate approximate omega field from rho field by assuming
         !     that Lagrange multiplier (pressure) field is zero. 
         ! (3) Output resulting omega file to file in symmetry-adapated format

         ! Check preconditions for RGRID_TO_FIELD
         if ( .not. unit_cell_flag ) then
            write(6,*) "Error: Must read UNIT_CELL before RHO_TO_OMEGA"
            exit op_loop
         else if (.not.discretize_flag) then
            write(6,*) &
                  "Error: Must read DISCRETIZATION before RHO_TO_OMEGA"
            exit op_loop
         else if (.not.basis_flag) then
            write(6,*) "Error: Must read BASIS before RHO_TO_OMEGA"
            exit op_loop
         end if
         iterate_flag = .FALSE.
         omega_flag = .FALSE.

         ! Read filenames from parameter file
         call <a href="io/io_mod_f.html#input">input</a>(input_filename, 'input_filename')
         call <a href="io/io_mod_f.html#input">input</a>(output_filename, 'output_filename')

         ! Read <a href="io/io_mod_f.html#input">input</a> rho field
         open(unit=field_unit,file=trim(input_filename),status='old')
         call <a href="io/field_io_mod_f.html#input_field">input_field</a>(rho,field_unit)
         close(field_unit)

         ! Compute approximate omega field
         allocate(omega_basis(<a href="scf/chemistry_mod_f.html#N_monomer">N_monomer</a>, <a href="crystal/basis_mod_f.html#N_star">N_star</a>))
         do alpha=1, <a href="scf/chemistry_mod_f.html#N_monomer">N_monomer</a>
            do i=1, <a href="crystal/basis_mod_f.html#N_star">N_star</a>
               omega_basis(alpha,i) = sum(<a href="scf/chemistry_mod_f.html#chi">chi</a>(:,alpha)*rho(:,i))
            end do
         end do

         ! Output omega field
         open(unit=field_unit,file=trim(output_filename),status='replace')
         call <a href="io/field_io_mod_f.html#output_field">output_field</a>(omega_basis,field_unit,group_name)
         close(field_unit)

         deallocate(omega_basis)

      case ('FINISH')

         ! Stop execution
         exit op_loop

      case default

         write(6,*) 'Error: Invalid op_string'
         exit op_loop

      end select

   end do op_loop


contains ! internal subroutines of program <strong>pscf_pd</strong>


   subroutine allocate_scf_arrays
   !-----------------------------------------------------------------
   ! Allocate arrays omega, rho, stress
   !-----------------------------------------------------------------
   integer                 :: i        ! error for file opening
   allocate(omega(<a href="scf/chemistry_mod_f.html#N_monomer">N_monomer</a>,<a href="crystal/basis_mod_f.html#N_star">N_star</a>), stat = i)
   if (i.ne.0 ) stop 'Error allocating omega'
   allocate(rho(<a href="scf/chemistry_mod_f.html#N_monomer">N_monomer</a>,<a href="crystal/basis_mod_f.html#N_star">N_star</a>), stat = i)
   if (i.ne.0) stop 'Error allocating rho'
   allocate(stress(<a href="crystal/unit_cell_mod_f.html#N_cell_param">N_cell_param</a>), stat = i )
   if (i.ne.0) stop 'Error allocating stress'
   end subroutine allocate_scf_arrays
   !=================================================================


   subroutine output_summary(prefix)
   !-----------------------------------------------------------------
   ! Writes the <a href="io/io_mod_f.html#output">output</a> summary to the file output_prefix//suffix
   !-----------------------------------------------------------------
   use <a href="scf/chemistry_mod_f.html#chemistry_mod">chemistry_mod</a>, only : <a href="scf/chemistry_mod_f.html#output_chemistry">output_chemistry</a>, <a href="scf/chemistry_mod_f.html#N_chain">N_chain</a>, <a href="scf/chemistry_mod_f.html#N_solvent">N_solvent</a>, &
                             <a href="scf/chemistry_mod_f.html#ensemble">ensemble</a>,<a href="scf/chemistry_mod_f.html#phi_chain">phi_chain</a>,<a href="scf/chemistry_mod_f.html#phi_solvent">phi_solvent</a>,<a href="scf/chemistry_mod_f.html#mu_chain">mu_chain</a>, &
                             <a href="scf/chemistry_mod_f.html#mu_solvent">mu_solvent</a>, <a href="scf/chemistry_mod_f.html#interaction_type">interaction_type</a>, <a href="scf/chemistry_mod_f.html#chi">chi</a>
   use <a href="scf/scf_mod_f.html#scf_mod">scf_mod</a>, only       : <a href="scf/scf_mod_f.html#free_energy_FH">free_energy_FH</a>
   character(*) :: prefix

   real(<a href="const_mod_f.html#long">long</a>) :: f_homo  ! FH free energy, kT / monomer

   open(file=trim(prefix)//'out',unit=out_unit,status='replace')
   call <a href="io/io_mod_f.html#set_io_units">set_io_units</a>(o=out_unit)

   ! Set version number for *.out file
   version%major = 1
   version%minor = 0
   call <a href="io/version_mod_f.html#output_version">output_version</a>(version, out_unit)

   ! Output in format of <a href="io/io_mod_f.html#input">input</a> driver file
   if (monomer_flag) then
      write(out_unit,*)
      call <a href="io/io_mod_f.html#output">output</a>('MONOMERS',f='N',j='L')
      call <a href="scf/chemistry_mod_f.html#output_monomers">output_monomers</a>(out_unit,'F')
   end if
   if (chain_flag) then
      write(out_unit,*)
      call <a href="io/io_mod_f.html#output">output</a>('CHAINS',f='N',j='L')
      call <a href="scf/chemistry_mod_f.html#output_chains">output_chains</a>(out_unit,'F')
   end if
   if (solvent_flag) then
      write(out_unit,*)
      call <a href="io/io_mod_f.html#output">output</a>('SOLVENTS',f='N',j='L')
      call <a href="scf/chemistry_mod_f.html#output_solvents">output_solvents</a>(out_unit,'F')
   end if
   if (composition_flag) then
      write(out_unit,*)
      call <a href="io/io_mod_f.html#output">output</a>('COMPOSITION',f='N',j='L')
      call <a href="scf/chemistry_mod_f.html#output_composition">output_composition</a>(out_unit,'F')
   end if
   if (interaction_flag) then
      write(out_unit,*)
      call <a href="io/io_mod_f.html#output">output</a>('INTERACTION',f='N',j='L')
      call <a href="scf/chemistry_mod_f.html#output_interaction">output_interaction</a>(out_unit,'F')
   end if
   if (unit_cell_flag) then
      write(out_unit,*)
      call <a href="io/io_mod_f.html#output">output</a>('UNIT_CELL',f='N',j='L')
      call <a href="crystal/unit_cell_mod_f.html#output_unit_cell">output_unit_cell</a>(out_unit,'F')
   end if
   if (discretize_flag) then
      write(out_unit,*)
      call <a href="io/io_mod_f.html#output">output</a>('DISCRETIZATION',f='N',j='L')
      call <a href="io/io_mod_f.html#output">output</a>(<a href="grid/grid_mod_f.html#ngrid">ngrid</a>,<a href="const_mod_f.html#dim">dim</a>,'<a href="grid/grid_mod_f.html#ngrid">ngrid</a>')
      call <a href="io/io_mod_f.html#output">output</a>(chain_step,'chain_step')
      !call <a href="io/io_mod_f.html#output">output</a>(extr_order, 'extr_order')
   end if
   if (basis_flag) then
      write(out_unit,*)
      call <a href="io/io_mod_f.html#output">output</a>('BASIS',f='N',j='L')
      call <a href="io/io_mod_f.html#output">output</a>(trim(group_name),'group_name')
   end if
   if (iterate_flag) then
      write(out_unit,*)
      call <a href="io/io_mod_f.html#output">output</a>('ITERATE',f='N',j='L')
      call <a href="io/io_mod_f.html#output">output</a>(trim(input_filename), 'input_filename')
      call <a href="io/io_mod_f.html#output">output</a>(trim(output_prefix),'output_prefix')
      call <a href="iterate/iterate_mod_f.html#output_iterate_param">output_iterate_param</a>
   end if
   write(out_unit,*)
   call <a href="io/io_mod_f.html#output">output</a>('FINISH',f='N',j='L')

   ! End <a href="io/io_mod_f.html#input">input</a> script section, begin additional information

   ! Thermodynamics
   write(out_unit,*)
   call <a href="io/io_mod_f.html#output">output</a>('THERMO',f='N',j='L')
   call <a href="io/io_mod_f.html#output">output</a>(f_Helmholtz,'f_Helmholtz')
   f_homo = <a href="scf/scf_mod_f.html#free_energy_FH">free_energy_FH</a>(<a href="scf/chemistry_mod_f.html#phi_chain">phi_chain</a>,<a href="scf/chemistry_mod_f.html#phi_solvent">phi_solvent</a>)
   call <a href="io/io_mod_f.html#output">output</a>(f_homo,     'f_homo')
   call <a href="io/io_mod_f.html#output">output</a>(pressure,   'pressure')
   select case(<a href="scf/chemistry_mod_f.html#ensemble">ensemble</a>)
   case(0) ! phi was <a href="io/io_mod_f.html#output">output</a> by <a href="io/io_mod_f.html#output">output</a> chemistry, so
      if( <a href="scf/chemistry_mod_f.html#N_chain">N_chain</a> > 0 ) then
         call <a href="io/io_mod_f.html#output">output</a>(<a href="scf/chemistry_mod_f.html#mu_chain">mu_chain</a>,<a href="scf/chemistry_mod_f.html#N_chain">N_chain</a>,'<a href="scf/chemistry_mod_f.html#mu_chain">mu_chain</a>',s='C')
      end if
      if( <a href="scf/chemistry_mod_f.html#N_solvent">N_solvent</a> > 0 ) then
         call <a href="io/io_mod_f.html#output">output</a>(<a href="scf/chemistry_mod_f.html#mu_solvent">mu_solvent</a>,<a href="scf/chemistry_mod_f.html#N_solvent">N_solvent</a>,'<a href="scf/chemistry_mod_f.html#mu_solvent">mu_solvent</a>',s='C')
      end if
   case(1) ! mu was <a href="io/io_mod_f.html#output">output</a> chemistry, so
      if( <a href="scf/chemistry_mod_f.html#N_chain">N_chain</a> > 0) then
         call <a href="io/io_mod_f.html#output">output</a>(<a href="scf/chemistry_mod_f.html#phi_chain">phi_chain</a>,<a href="scf/chemistry_mod_f.html#N_chain">N_chain</a>,'<a href="scf/chemistry_mod_f.html#phi_chain">phi_chain</a>',s='C')
      end if
      if ( <a href="scf/chemistry_mod_f.html#N_solvent">N_solvent</a> > 0) then
         call <a href="io/io_mod_f.html#output">output</a>(<a href="scf/chemistry_mod_f.html#phi_solvent">phi_solvent</a>,<a href="scf/chemistry_mod_f.html#N_solvent">N_solvent</a>,'<a href="scf/chemistry_mod_f.html#phi_solvent">phi_solvent</a>',s='C')
      end if
   end select
   call <a href="io/io_mod_f.html#output">output</a>(stress,<a href="crystal/unit_cell_mod_f.html#N_cell_param">N_cell_param</a>,'stress')

   ! Output <a href="scf/chemistry_mod_f.html#chi">chi</a> if <a href="scf/chemistry_mod_f.html#chi">chi</a> is <a href="io/io_mod_f.html#input">input</a> as <a href="scf/chemistry_mod_f.html#chi">chi</a> = <a href="scf/chemistry_mod_f.html#chi_A">chi_A</a>/T + B
   if (<a href="scf/chemistry_mod_f.html#interaction_type">interaction_type</a> =='chi_T') then
      call <a href="io/io_mod_f.html#output">output</a>(<a href="scf/chemistry_mod_f.html#chi">chi</a>,<a href="scf/chemistry_mod_f.html#N_monomer">N_monomer</a>,<a href="scf/chemistry_mod_f.html#N_monomer">N_monomer</a>,'<a href="scf/chemistry_mod_f.html#chi">chi</a>',s='L')
   end if


   ! Timing and resource statistics
   write(out_unit,*)
   call <a href="io/io_mod_f.html#output">output</a>('STATISTICS',f='N',j='L')
   call <a href="io/io_mod_f.html#output">output</a>(<a href="crystal/basis_mod_f.html#N_star">N_star</a>,'<a href="crystal/basis_mod_f.html#N_star">N_star</a>')
   call <a href="io/io_mod_f.html#output">output</a>(error,'Final Error')
   call <a href="io/io_mod_f.html#output">output</a>(itr,'Iterations')
   call <a href="io/io_mod_f.html#output">output</a>(basis_time,'Basis Time')
   call <a href="io/io_mod_f.html#output">output</a>(scf_time,'SCF Time')

   close(out_unit)             ! close output_prefix//'out' file
   call <a href="io/io_mod_f.html#set_io_units">set_io_units</a>(o=6)      ! reset default echo unit to stdout

   end subroutine output_summary
   !============================================================


   subroutine output_fields(prefix)
   !-----------------------------------------------------------------
   ! Writes the <a href="io/io_mod_f.html#output">output</a> summary to the file output_prefix//suffix
   !-----------------------------------------------------------------
   character(*) :: prefix

   open(file=trim(prefix)//'omega', unit=field_unit,status='replace')
   call <a href="io/field_io_mod_f.html#output_field">output_field</a>(omega,field_unit,group_name)
   close(field_unit)

   open(file=trim(prefix)//'rho',unit=field_unit,status='replace')
   call <a href="io/field_io_mod_f.html#output_field">output_field</a>(rho,field_unit,group_name)
   close(field_unit)

   end subroutine output_fields
   !============================================================

end program <strong>pscf_pd</strong>
</pre>
</body>
</html>